//바킹독님 풀이

#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    // -100 <= v && v <= 100 이므로 음수도 저장할 수 있는 공간을 배열에 추가
    int N, v, a[201] = {};
    cin >> N;

    // 입력값을 배열에 저장
    while(N--){
        int t;
        cin >> t;
        // 음수도 인덱스로 접근하기 위해 기존 인덱스+100으로 배열에 저장
        a[t+100]++;
    }

    // v의 개수를 배열에서 확인
    cin >> v;
    cout << a[v+100];
}

/*
두 풀이의 주요 차이점:

1. **배열 크기 및 초기화**
   - 바킹독님: 정수 범위가 -100 <= v <= 100이므로 배열 크기를 201로 설정하여 음수도 인덱스로 사용할 수 있게 함.
     ```cpp
     int a[201] = {};
     ```
   - 나의 풀이: 입력받은 N개의 정수를 저장하는 배열을 동적으로 생성함.
     ```cpp
     int arr[N];
     ```

2. **입력값 저장 방법**
   - 바킹독님: 입력값을 바로 배열에 저장하면서 카운트를 증가시킴.
     ```cpp
     while(N--){
         int t;
         cin >> t;
         a[t+100]++;
     }
     ```
   - 나의 풀이: 입력값을 먼저 배열에 저장한 후 별도의 루프를 통해 카운트를 셈.
     ```cpp
     for (int i = 0; i < N; i++) {
         cin >> arr[i];
     }
     ```

3. **찾으려는 정수 v의 개수 확인 방법**
   - 바킹독님: 배열 인덱스로 바로 접근하여 결과를 출력.
     ```cpp
     cin >> v;
     cout << a[v+100];
     ```
   - 나의 풀이: 루프를 통해 배열을 순회하며 v의 개수를 셈.
     ```cpp
     cin >> v;
     for (int i = 0; i < N; i++) {
         if (arr[i] == v) {
             count++;
         }
     }
     cout << count << '\n';
     ```

4. **시간 복잡도**
   - 바킹독님: O(N) - 입력을 받으면서 바로 카운트를 셈.
   - 나의 풀이: O(N) - 입력을 받은 후 루프를 통해 카운트를 셈.

5. **공간 복잡도**
   - 바킹독님: O(1) - 고정 크기의 배열을 사용.
   - 나의 풀이: O(N) - 입력 크기에 따라 배열 크기가 달라짐.

두 풀이 모두 정답을 도출하지만, 바킹독님의 풀이는 더 효율적이며 메모리 사용이 일정함.
*/